<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manifold Predictor Showcase</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: #20232a;
      color: #61dafb;
      padding: 1rem;
      text-align: center;
    }
    .container {
      padding: 2rem;
      max-width: 1200px;
      margin: auto;
    }
    .search-input {
      width: 100%;
      padding: 0.5rem;
      font-size: 1rem;
      margin-bottom: 2rem;
      box-sizing: border-box;
    }
    #predictions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
    }
    .card {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin-bottom: 1.5rem;
      transition: 0.3s;
    }
    .card:hover {
      transform: scale(1.01);
    }
    .question {
      font-size: 1.2rem;
      font-weight: bold;
    }
    .probability {
      color: #333;
      font-size: 1.1rem;
    }
    .date {
      font-size: 0.9rem;
      color: gray;
    }
    .button, #loadMore {
      margin-top: 1rem;
      background-color: #61dafb;
      color: #000;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
    }
    .hidden { display: none; }
  </style>
</head>
   <!-- About Section -->
    <section id="about">
      <h2>About this Project</h2>
      <p>
        The Manifold Market Predictor is an <strong>unofficial, educational tool</strong> that uses real-time data from 
        Manifold Markets to forecast outcomes of unresolved binary questions. It combines <strong>GPT-3.5</strong> (for 
        analyzing the market question) and a <strong>Random Forest</strong> machine learning model (trained on past resolved markets) 
        to estimate the probability of a "YES" resolution for each market:contentReference[oaicite:25]{index=25}:contentReference[oaicite:26]{index=26}. The model outputs a ranked list of 
        predictions, as shown above, without needing to wait for actual market resolutions:contentReference[oaicite:27]{index=27}.
      </p>
      <p>
        <strong>Disclaimer:</strong> This project is not affiliated with Manifold Markets. It is for research and educational purposes only, 
        and its predictions are speculative. Use these results for curiosity and insight, not as financial advice or a guaranteed edge in forecasting:contentReference[oaicite:28]{index=28}.
      </p>
    </section>
  </main>

  <footer>
    Not affiliated with <a href="https://manifold.markets" target="_blank">Manifold Markets</a>. Predictions are for educational use only.
    <p>Connect with the creator:</p>
    <ul class="contacts">
      <li><a href="https://www.instagram.com/dinmukhammed.toleubay/" target="_blank">Instagram</a></li>
      <li><a href="https://github.com/DMCHERy/dmchery.github.io" target="_blank">GitHub</a></li>
      <li><a href="mailto:dinmukhammed.toleubay@gmail.com">Email</a></li>
    </ul>
  </footer>

<body>
  <header>
    <h1>Manifold Market Predictor</h1>
    <p>Powered by GPT + Random Forest</p>
  </header>

  <div class="container">
    <input type="text" id="searchInput" class="search-input" placeholder="Search predictions...">
    <div id="predictions"></div>
    <button id="loadMore" class="hidden">Load More</button>
  </div>

  <script>
    let allPredictions = [];
    let visibleCount = 0;
    const BATCH_SIZE = 7;

    function renderPredictions(batch = false) {
      const container = document.getElementById('predictions');
      const fragment = document.createDocumentFragment();
      const end = Math.min(visibleCount + BATCH_SIZE, allPredictions.length);

      for (let i = visibleCount; i < end; i++) {
        const pred = allPredictions[i];
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.question = pred.question.toLowerCase();
        const result = pred.probability >= 0.5 ? "Predicted YES" : "Predicted NO";
        const percent = (pred.probability * 100).toFixed(1);
        card.innerHTML = `
          <div class="question">${pred.question}</div>
          <div class="probability">${result}: <strong>${percent}%</strong></div>
          <div class="date">Predicted on ${pred.date}</div>
          <a href="${pred.link}" target="_blank"><button class="button">View on Manifold</button></a>
        `;
        fragment.appendChild(card);
      }

      container.appendChild(fragment);
      visibleCount = end;

      const loadMoreBtn = document.getElementById('loadMore');
      if (visibleCount < allPredictions.length) {
        loadMoreBtn.classList.remove('hidden');
      } else {
        loadMoreBtn.classList.add('hidden');
      }
    }

    async function loadPredictions() {
      try {
        const response = await fetch('predictions.json');
        if (!response.ok) throw new Error('File not found');
        allPredictions = await response.json();
        allPredictions.reverse();
        renderPredictions();
      } catch (err) {
        console.error('Failed to load predictions:', err);
      }
    }

    document.getElementById('loadMore').addEventListener('click', () => renderPredictions(true));

    document.getElementById('searchInput').addEventListener('input', e => {
      const query = e.target.value.toLowerCase();
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => {
        card.style.display = card.dataset.question.includes(query) ? 'block' : 'none';
      });
    });

    loadPredictions();
  </script>
</body>
</html>
